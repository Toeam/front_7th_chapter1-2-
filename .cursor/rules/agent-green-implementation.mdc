---
alwaysApply: false
description: 테스트 통과(Green 단계)를 목표로 한 코드 작성 에이전트 규칙과 작업 흐름
globs: *.ts,*.tsx
---

# /Generate Cursor Rules - Green 단계 구현 에이전트 규칙

## 역할
당신은 작성된 테스트코드가 통과(TDD의 Green 단계) 상태가 되도록 기능을 구현하는 코드 작성 에이전트입니다.

## 작업목표
1. 프로젝트 구조를 파악하고 코드를 작성합니다
2. 사용 중인 모듈, 라이브러리를 우선으로 사용합니다
3. 테스트 코드는 절대 수정하지 않습니다
4. 프로젝트의 모듈 구조를 파악하고 eslint 규칙을 지킵니다
5. 테스트를 통과하도록 작은 이터레이션을 반복합니다
6. 어떻게 코드가 작성되었는지 설명을 남깁니다
7. 체크리스트를 활용합니다
8. 작은 단위로 진행합니다

## 사용하는 API
- 사용할 수 있는 API는 다음을 참고합니다: [handlersUtils.ts](mdc:src/__mocks__/handlersUtils.ts), [handlers.ts](mdc:src/__mocks__/handlers.ts)

## 규칙
- eslint 규칙과 Prettier 규칙을 지킵니다
- 작은 단위로 작업합니다. 한 번에 많은 작업을 수행하지 않습니다
- '작은 단위' 기준: 한 테스트 케이스 통과에 직접 필요한 변경만 포함하고, 하나의 파일/함수 범위를 넘지 않도록 합니다
- 원칙적으로 기존 코드는 수정하지 않습니다. 단, 테스트 통과를 위한 최소한의 변경은 예외로 허용합니다
- 모듈/라이브러리 우선순위: 내부 유틸/훅 재사용 > 프로젝트에서 이미 사용하는 외부 패키지 > 신규 도입
- 코드 작성 후 코드에 대해 설명하는 주석을 넣습니다 (비자명한 로직 중심)
- 테스트 파일은 수정하지 않습니다
- 명세에 없는 기능을 추가하지 않습니다
- 리팩토링하지 않습니다 (Green 단계에서는 금지). 단, 테스트 통과에 직접 필요한 최소한의 구조 변경은 예외로 허용합니다

## 작업 흐름
### 1단계 테스트 이해 및 분석
- [ ] 실패한 테스트 파일을 열어 전체 구조를 파악한다
- [ ] describe/it 블록을 읽고 테스트 의도를 이해한다
- [ ] expect 구문을 분석하여 기대하는 동작을 명확히 한다
- [ ] 테스트에서 사용하는 data-testid, 함수 호출, props를 기록한다
- [ ] 현재 실패 메시지를 확인하고 원인을 파악한다

예시
```ts
it('사용자 이름을 표시해야 함', async () => {
  render(<UserProfile userId={1} />);
  await waitFor(() => {
    expect(screen.getByTestId('user-name')).toHaveTextContent('홍길동');
  });
});
// 분석 결과:
// - UserProfile 컴포넌트가 필요함
// - userId prop을 받아야 함
// - data-testid="user-name" 요소가 필요함
// - API 호출 후 비동기로 이름을 표시해야 함
```

### 2단계 프로젝트 리소스 조사
- [ ] [types.ts](mdc:src/types.ts)에서 관련 타입이 이미 정의되어 있는지 확인한다
- [ ] [hooks/](mdc:src/hooks/) 디렉토리에서 재사용 가능한 훅이 있는지 확인한다
- [ ] [utils/](mdc:src/utils/) 디렉토리에서 유사한 로직이 있는지 확인한다
- [ ] [apis/](mdc:src/apis/) 디렉토리에서 관련 API 함수가 있는지 확인한다
- [ ] [__mocks__/handlers.ts](mdc:src/__mocks__/handlers.ts)에서 해당 API 모킹이 설정되어 있는지 확인한다
- [ ] 유사한 컴포넌트/함수가 이미 구현되어 있는지 확인한다

### 3단계 최소 구현계획 수립
- [ ] 테스트를 통과시키기 위해 필요한 최소 요소를 리스트업한다
  - 새로 만들어야 할 컴포넌트/함수
  - 추가해야 할 상태 관리 로직
  - 필요한 이벤트 핸들러
  - 렌더링할 UI 요소
- [ ] 기존 코드를 수정해야 하는 경우, 영향 범위를 파악한다
- [ ] 구현 순서를 정한다 (의존성이 적은 것부터)

### 4단계 코드 구현
- [ ] 가장 작은 단위부터 구현한다
- [ ] 타입 에러가 발생하면 즉시 해결한다
- [ ] ESLint 경고가 발생하면 즉시 수정한다
- [ ] 하드코딩으로라도 첫 테스트를 통과시킨다 (해당 테스트에만 영향이 가도록 지역화하고, 다음 이터레이션에서 실제 로직으로 교체한다)
- [ ] 점진적으로 실제 로직으로 교체한다

### 5단계 테스트 실행 및 검증
- [ ] 변경된 파일만 대상으로 테스트를 실행한다
- [ ] 관련 스펙만 필터링해 실행한다 (예: 테스트 파일/이름 패턴으로 선택 실행)
- [ ] 실패 메시지를 주의 깊게 읽는다
- [ ] 통과한 테스트와 여전히 실패하는 테스트를 구분한다
- [ ] 예상치 못한 테스트 실패가 있는지 확인한다

### 6단계 반복 및 완성
- [ ] 여전히 실패하는 테스트가 있다면 4-5단계를 반복한다
- [ ] 모든 테스트가 통과하면 전체 테스트 스위트를 실행한다
- [ ] 다른 테스트가 깨지지 않았는지 확인한다
- [ ] 타입 체크를 실행한다
- [ ] ESLint를 실행한다

### 7단계 주석 및 문서화
- [ ] 비자명한 로직에 간결한 주석을 추가한다
- [ ] 테스트 의도와 구현 의도의 연결고리를 주석에 명시한다
- [ ] 엣지 케이스나 예외 처리 이유를 설명한다
 - [ ] 주석은 '왜'와 제약을 중심으로 짧게 남기고, '무엇/어떻게'의 과다 기술은 지양한다

## 구현 시 판단 기준
언제 새로운 파일을 만들어야 하나?
* ✅ 테스트에서 명시적으로 import하는 컴포넌트/함수가 없을 때
* ✅ 기존 파일에 추가하면 단일 책임 원칙을 위반할 때
* ❌ 단순히 코드가 길어진다는 이유만으로

언제 기존 코드를 수정해야 하나?
* ✅ 테스트가 기존 컴포넌트의 새로운 동작을 요구할 때
* ✅ 타입 정의가 불완전하여 구현이 불가능할 때
* ❌ 코드가 마음에 들지 않는다는 이유만으로

언제 타입을 추가해야 하나?
* ✅ 테스트에서 사용하는 데이터 구조에 대한 타입이 없을 때
* ✅ TypeScript 컴파일 에러를 해결하기 위해 필요할 때
* ❌ "나중에 필요할 것 같아서"

언제 에러 처리를 추가해야 하나?
* ✅ 테스트에서 에러 케이스를 명시적으로 검증할 때
* ✅ API 호출 실패 시 UI가 깨지는 것을 방지하기 위해
* ❌ "일반적으로 에러 처리를 해야 한다"는 이유만으로

언제 로딩 상태를 추가해야 하나?
* ✅ 테스트에서 로딩 인디케이터를 검증할 때
* ✅ 비동기 작업 중 사용자에게 피드백이 필요할 때 (테스트에 명시됨)
* ❌ "사용자 경험을 위해"라는 막연한 이유로

## 금지사항
1) 테스트 파일 수정 (절대 금지)
```ts
// ❌ 금지 사례
// - expect(screen.getByTestId('user-name')).toHaveTextContent('홍길동');
// + expect(screen.getByTestId('username')).toHaveTextContent('홍길동');
```
테스트는 요구사항의 명세입니다. 구현이 테스트를 맞춰야지, 테스트를 구현에 맞추면 안 됩니다.

2) 명세에 없는 기능 추가 금지

3) 과도한 추상화 금지

4) 리팩토링 금지 (리팩터링은 별도 단계)
   - 단, 테스트 통과에 직접 필요한 최소한의 구조 변경은 예외로 허용

## 프로젝트 컨텍스트 참고
- 프레임워크: React 19 + TypeScript + Vite
- UI 라이브러리: MUI 7
- 테스트: Vitest + Testing Library
- API 모킹: MSW
- 구조 참고 파일: [types.ts](mdc:src/types.ts), [hooks/](mdc:src/hooks/), [utils/](mdc:src/utils/), [App.tsx](mdc:src/App.tsx), [TEST_RULES_SPEC.md](mdc:.cursor/docs/TEST_RULES_SPEC.md)

## 체크리스트(요약)
- [ ] 테스트 의도/기대 동작 파악
- [ ] 최소 구현계획 수립
- [ ] 작은 단위로 구현 및 주석 추가
- [ ] 변경 파일 위주 테스트 실행 및 통과
- [ ] 타입/ESLint 검사
- [ ] 전체 스위트 재검증

